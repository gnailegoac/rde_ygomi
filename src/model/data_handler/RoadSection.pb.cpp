// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RoadSection.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "RoadSection.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* GeometryPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GeometryPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* Geometry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Geometry_reflection_ = NULL;
const ::google::protobuf::Descriptor* Landmark_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Landmark_reflection_ = NULL;
const ::google::protobuf::Descriptor* Lane_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Lane_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaneBoundary_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaneBoundary_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaneModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaneModel_reflection_ = NULL;
const ::google::protobuf::Descriptor* RoadSection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RoadSection_reflection_ = NULL;
const ::google::protobuf::Descriptor* RoadSections_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RoadSections_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ShapeType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* LandmarkType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* LaneType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* LaneBoundaryType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_RoadSection_2eproto() {
  protobuf_AddDesc_RoadSection_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "RoadSection.proto");
  GOOGLE_CHECK(file != NULL);
  GeometryPoint_descriptor_ = file->message_type(0);
  static const int GeometryPoint_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GeometryPoint, lat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GeometryPoint, lon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GeometryPoint, height_),
  };
  GeometryPoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GeometryPoint_descriptor_,
      GeometryPoint::default_instance_,
      GeometryPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GeometryPoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GeometryPoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GeometryPoint));
  Geometry_descriptor_ = file->message_type(1);
  static const int Geometry_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Geometry, points_),
  };
  Geometry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Geometry_descriptor_,
      Geometry::default_instance_,
      Geometry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Geometry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Geometry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Geometry));
  Landmark_descriptor_ = file->message_type(2);
  static const int Landmark_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, geometry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, lateraloffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, shapetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, colorrgb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, widthcm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, heightcm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, countrycode_),
  };
  Landmark_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Landmark_descriptor_,
      Landmark::default_instance_,
      Landmark_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmark, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Landmark));
  Lane_descriptor_ = file->message_type(3);
  static const int Lane_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, centerline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, laneid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, predecessorlaneids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, predecessorsectionid_),
  };
  Lane_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Lane_descriptor_,
      Lane::default_instance_,
      Lane_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Lane));
  LaneBoundary_descriptor_ = file->message_type(4);
  static const int LaneBoundary_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary, geometry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary, type_),
  };
  LaneBoundary_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LaneBoundary_descriptor_,
      LaneBoundary::default_instance_,
      LaneBoundary_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LaneBoundary));
  LaneModel_descriptor_ = file->message_type(5);
  static const int LaneModel_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneModel, lanes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneModel, boundaries_),
  };
  LaneModel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LaneModel_descriptor_,
      LaneModel::default_instance_,
      LaneModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneModel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneModel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LaneModel));
  RoadSection_descriptor_ = file->message_type(6);
  static const int RoadSection_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadSection, sectionid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadSection, lanemodel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadSection, landmarks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadSection, roadsectioncenterline_),
  };
  RoadSection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RoadSection_descriptor_,
      RoadSection::default_instance_,
      RoadSection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadSection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadSection, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RoadSection));
  RoadSections_descriptor_ = file->message_type(7);
  static const int RoadSections_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadSections, roadsections_),
  };
  RoadSections_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RoadSections_descriptor_,
      RoadSections::default_instance_,
      RoadSections_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadSections, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadSections, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RoadSections));
  ShapeType_descriptor_ = file->enum_type(0);
  LandmarkType_descriptor_ = file->enum_type(1);
  LaneType_descriptor_ = file->enum_type(2);
  LaneBoundaryType_descriptor_ = file->enum_type(3);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_RoadSection_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GeometryPoint_descriptor_, &GeometryPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Geometry_descriptor_, &Geometry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Landmark_descriptor_, &Landmark::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Lane_descriptor_, &Lane::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LaneBoundary_descriptor_, &LaneBoundary::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LaneModel_descriptor_, &LaneModel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RoadSection_descriptor_, &RoadSection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RoadSections_descriptor_, &RoadSections::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_RoadSection_2eproto() {
  delete GeometryPoint::default_instance_;
  delete GeometryPoint_reflection_;
  delete Geometry::default_instance_;
  delete Geometry_reflection_;
  delete Landmark::default_instance_;
  delete Landmark_reflection_;
  delete Lane::default_instance_;
  delete Lane_reflection_;
  delete LaneBoundary::default_instance_;
  delete LaneBoundary_reflection_;
  delete LaneModel::default_instance_;
  delete LaneModel_reflection_;
  delete RoadSection::default_instance_;
  delete RoadSection_reflection_;
  delete RoadSections::default_instance_;
  delete RoadSections_reflection_;
}

void protobuf_AddDesc_RoadSection_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021RoadSection.proto\"9\n\rGeometryPoint\022\013\n\003"
    "lat\030\001 \001(\001\022\013\n\003lon\030\002 \001(\001\022\016\n\006height\030\003 \001(\001\"*"
    "\n\010Geometry\022\036\n\006points\030\001 \003(\0132\016.GeometryPoi"
    "nt\"\304\001\n\010Landmark\022\033\n\010geometry\030\001 \001(\0132\t.Geom"
    "etry\022\025\n\rlateralOffset\030\002 \001(\005\022\033\n\004type\030\003 \001("
    "\0162\r.LandmarkType\022\035\n\tshapeType\030\004 \001(\0162\n.Sh"
    "apeType\022\020\n\010colorRgb\030\005 \001(\005\022\017\n\007widthCm\030\006 \001"
    "(\002\022\020\n\010heightCm\030\007 \001(\002\022\023\n\013countryCode\030\010 \001("
    "\005\"\210\001\n\004Lane\022\035\n\ncenterLine\030\001 \001(\0132\t.Geometr"
    "y\022\027\n\004type\030\002 \001(\0162\t.LaneType\022\016\n\006laneId\030\003 \001"
    "(\r\022\032\n\022predecessorLaneIds\030\004 \003(\r\022\034\n\024predec"
    "essorSectionId\030\005 \001(\r\"L\n\014LaneBoundary\022\033\n\010"
    "geometry\030\001 \001(\0132\t.Geometry\022\037\n\004type\030\002 \001(\0162"
    "\021.LaneBoundaryType\"D\n\tLaneModel\022\024\n\005lanes"
    "\030\001 \003(\0132\005.Lane\022!\n\nboundaries\030\002 \003(\0132\r.Lane"
    "Boundary\"\207\001\n\013RoadSection\022\021\n\tsectionId\030\001 "
    "\001(\r\022\035\n\tlaneModel\030\002 \001(\0132\n.LaneModel\022\034\n\tla"
    "ndmarks\030\003 \003(\0132\t.Landmark\022(\n\025roadSectionC"
    "enterLine\030\004 \001(\0132\t.Geometry\"2\n\014RoadSectio"
    "ns\022\"\n\014roadSections\030\001 \003(\0132\014.RoadSection*\200"
    "\001\n\tShapeType\022\025\n\021SHAPETYPE_UNKNOWN\020\000\022\024\n\020S"
    "HAPETYPE_CIRCLE\020\001\022\027\n\023SHAPETYPE_RECTANGLE"
    "\020\002\022\025\n\021SHAPETYPE_DIAMOND\020\003\022\026\n\022SHAPETYPE_T"
    "RIANGLE\020\004*y\n\014LandmarkType\022\030\n\024LANDMARKTYP"
    "E_UNKNOWN\020\000\022\034\n\030LANDMARKTYPE_TRAFFICSIGN\020"
    "\001\022\032\n\026LANDMARKTYPE_GUARDRAIL\020\002\022\025\n\021LANDMAR"
    "KTYPE_CURB\020\003*\206\001\n\010LaneType\022\024\n\020LANETYPE_UN"
    "KNOWN\020\000\022\023\n\017LANETYPE_NORMAL\020\001\022\025\n\021LANETYPE"
    "_SHOULDER\020\002\022\022\n\016LANETYPE_ENTRY\020\003\022\021\n\rLANET"
    "YPE_EXIT\020\004\022\021\n\rLANETYPE_RAMP\020\005*\216\002\n\020LaneBo"
    "undaryType\022\034\n\030LANEBOUNDARYTYPE_UNKNOWN\020\000"
    "\022#\n\037LANEBOUNDARYTYPE_MARKING_DASHED\020\001\022\"\n"
    "\036LANEBOUNDARYTYPE_MARKING_SOLID\020\002\022#\n\037LAN"
    "EBOUNDARYTYPE_MARKING_DOUBLE\020\003\022\'\n#LANEBO"
    "UNDARYTYPE_MARKING_BOTTS_DOTS\020\004\022\"\n\036LANEB"
    "OUNDARYTYPE_MARKING_BLOCK\020\005\022!\n\035LANEBOUND"
    "ARYTYPE_MARKING_NONE\020\006", 1462);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "RoadSection.proto", &protobuf_RegisterTypes);
  GeometryPoint::default_instance_ = new GeometryPoint();
  Geometry::default_instance_ = new Geometry();
  Landmark::default_instance_ = new Landmark();
  Lane::default_instance_ = new Lane();
  LaneBoundary::default_instance_ = new LaneBoundary();
  LaneModel::default_instance_ = new LaneModel();
  RoadSection::default_instance_ = new RoadSection();
  RoadSections::default_instance_ = new RoadSections();
  GeometryPoint::default_instance_->InitAsDefaultInstance();
  Geometry::default_instance_->InitAsDefaultInstance();
  Landmark::default_instance_->InitAsDefaultInstance();
  Lane::default_instance_->InitAsDefaultInstance();
  LaneBoundary::default_instance_->InitAsDefaultInstance();
  LaneModel::default_instance_->InitAsDefaultInstance();
  RoadSection::default_instance_->InitAsDefaultInstance();
  RoadSections::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_RoadSection_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_RoadSection_2eproto {
  StaticDescriptorInitializer_RoadSection_2eproto() {
    protobuf_AddDesc_RoadSection_2eproto();
  }
} static_descriptor_initializer_RoadSection_2eproto_;
const ::google::protobuf::EnumDescriptor* ShapeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShapeType_descriptor_;
}
bool ShapeType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LandmarkType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LandmarkType_descriptor_;
}
bool LandmarkType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LaneType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaneType_descriptor_;
}
bool LaneType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LaneBoundaryType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaneBoundaryType_descriptor_;
}
bool LaneBoundaryType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int GeometryPoint::kLatFieldNumber;
const int GeometryPoint::kLonFieldNumber;
const int GeometryPoint::kHeightFieldNumber;
#endif  // !_MSC_VER

GeometryPoint::GeometryPoint()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GeometryPoint)
}

void GeometryPoint::InitAsDefaultInstance() {
}

GeometryPoint::GeometryPoint(const GeometryPoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GeometryPoint)
}

void GeometryPoint::SharedCtor() {
  _cached_size_ = 0;
  lat_ = 0;
  lon_ = 0;
  height_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GeometryPoint::~GeometryPoint() {
  // @@protoc_insertion_point(destructor:GeometryPoint)
  SharedDtor();
}

void GeometryPoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GeometryPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GeometryPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GeometryPoint_descriptor_;
}

const GeometryPoint& GeometryPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RoadSection_2eproto();
  return *default_instance_;
}

GeometryPoint* GeometryPoint::default_instance_ = NULL;

GeometryPoint* GeometryPoint::New() const {
  return new GeometryPoint;
}

void GeometryPoint::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GeometryPoint*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(lat_, height_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GeometryPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:GeometryPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double lat = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lat_)));
          set_has_lat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_lon;
        break;
      }

      // optional double lon = 2;
      case 2: {
        if (tag == 17) {
         parse_lon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lon_)));
          set_has_lon();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_height;
        break;
      }

      // optional double height = 3;
      case 3: {
        if (tag == 25) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GeometryPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GeometryPoint)
  return false;
#undef DO_
}

void GeometryPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GeometryPoint)
  // optional double lat = 1;
  if (has_lat()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->lat(), output);
  }

  // optional double lon = 2;
  if (has_lon()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->lon(), output);
  }

  // optional double height = 3;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->height(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GeometryPoint)
}

::google::protobuf::uint8* GeometryPoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GeometryPoint)
  // optional double lat = 1;
  if (has_lat()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->lat(), target);
  }

  // optional double lon = 2;
  if (has_lon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->lon(), target);
  }

  // optional double height = 3;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->height(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GeometryPoint)
  return target;
}

int GeometryPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double lat = 1;
    if (has_lat()) {
      total_size += 1 + 8;
    }

    // optional double lon = 2;
    if (has_lon()) {
      total_size += 1 + 8;
    }

    // optional double height = 3;
    if (has_height()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GeometryPoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GeometryPoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GeometryPoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GeometryPoint::MergeFrom(const GeometryPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lat()) {
      set_lat(from.lat());
    }
    if (from.has_lon()) {
      set_lon(from.lon());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GeometryPoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GeometryPoint::CopyFrom(const GeometryPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeometryPoint::IsInitialized() const {

  return true;
}

void GeometryPoint::Swap(GeometryPoint* other) {
  if (other != this) {
    std::swap(lat_, other->lat_);
    std::swap(lon_, other->lon_);
    std::swap(height_, other->height_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GeometryPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GeometryPoint_descriptor_;
  metadata.reflection = GeometryPoint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Geometry::kPointsFieldNumber;
#endif  // !_MSC_VER

Geometry::Geometry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Geometry)
}

void Geometry::InitAsDefaultInstance() {
}

Geometry::Geometry(const Geometry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Geometry)
}

void Geometry::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Geometry::~Geometry() {
  // @@protoc_insertion_point(destructor:Geometry)
  SharedDtor();
}

void Geometry::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Geometry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Geometry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Geometry_descriptor_;
}

const Geometry& Geometry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RoadSection_2eproto();
  return *default_instance_;
}

Geometry* Geometry::default_instance_ = NULL;

Geometry* Geometry::New() const {
  return new Geometry;
}

void Geometry::Clear() {
  points_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Geometry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Geometry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .GeometryPoint points = 1;
      case 1: {
        if (tag == 10) {
         parse_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_points;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Geometry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Geometry)
  return false;
#undef DO_
}

void Geometry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Geometry)
  // repeated .GeometryPoint points = 1;
  for (int i = 0; i < this->points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->points(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Geometry)
}

::google::protobuf::uint8* Geometry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Geometry)
  // repeated .GeometryPoint points = 1;
  for (int i = 0; i < this->points_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->points(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Geometry)
  return target;
}

int Geometry::ByteSize() const {
  int total_size = 0;

  // repeated .GeometryPoint points = 1;
  total_size += 1 * this->points_size();
  for (int i = 0; i < this->points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->points(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Geometry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Geometry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Geometry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Geometry::MergeFrom(const Geometry& from) {
  GOOGLE_CHECK_NE(&from, this);
  points_.MergeFrom(from.points_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Geometry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Geometry::CopyFrom(const Geometry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Geometry::IsInitialized() const {

  return true;
}

void Geometry::Swap(Geometry* other) {
  if (other != this) {
    points_.Swap(&other->points_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Geometry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Geometry_descriptor_;
  metadata.reflection = Geometry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Landmark::kGeometryFieldNumber;
const int Landmark::kLateralOffsetFieldNumber;
const int Landmark::kTypeFieldNumber;
const int Landmark::kShapeTypeFieldNumber;
const int Landmark::kColorRgbFieldNumber;
const int Landmark::kWidthCmFieldNumber;
const int Landmark::kHeightCmFieldNumber;
const int Landmark::kCountryCodeFieldNumber;
#endif  // !_MSC_VER

Landmark::Landmark()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Landmark)
}

void Landmark::InitAsDefaultInstance() {
  geometry_ = const_cast< ::Geometry*>(&::Geometry::default_instance());
}

Landmark::Landmark(const Landmark& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Landmark)
}

void Landmark::SharedCtor() {
  _cached_size_ = 0;
  geometry_ = NULL;
  lateraloffset_ = 0;
  type_ = 0;
  shapetype_ = 0;
  colorrgb_ = 0;
  widthcm_ = 0;
  heightcm_ = 0;
  countrycode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Landmark::~Landmark() {
  // @@protoc_insertion_point(destructor:Landmark)
  SharedDtor();
}

void Landmark::SharedDtor() {
  if (this != default_instance_) {
    delete geometry_;
  }
}

void Landmark::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Landmark::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Landmark_descriptor_;
}

const Landmark& Landmark::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RoadSection_2eproto();
  return *default_instance_;
}

Landmark* Landmark::default_instance_ = NULL;

Landmark* Landmark::New() const {
  return new Landmark;
}

void Landmark::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Landmark*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(lateraloffset_, countrycode_);
    if (has_geometry()) {
      if (geometry_ != NULL) geometry_->::Geometry::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Landmark::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Landmark)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Geometry geometry = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_geometry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_lateralOffset;
        break;
      }

      // optional int32 lateralOffset = 2;
      case 2: {
        if (tag == 16) {
         parse_lateralOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lateraloffset_)));
          set_has_lateraloffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .LandmarkType type = 3;
      case 3: {
        if (tag == 24) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::LandmarkType_IsValid(value)) {
            set_type(static_cast< ::LandmarkType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_shapeType;
        break;
      }

      // optional .ShapeType shapeType = 4;
      case 4: {
        if (tag == 32) {
         parse_shapeType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ShapeType_IsValid(value)) {
            set_shapetype(static_cast< ::ShapeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_colorRgb;
        break;
      }

      // optional int32 colorRgb = 5;
      case 5: {
        if (tag == 40) {
         parse_colorRgb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &colorrgb_)));
          set_has_colorrgb();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_widthCm;
        break;
      }

      // optional float widthCm = 6;
      case 6: {
        if (tag == 53) {
         parse_widthCm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &widthcm_)));
          set_has_widthcm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_heightCm;
        break;
      }

      // optional float heightCm = 7;
      case 7: {
        if (tag == 61) {
         parse_heightCm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &heightcm_)));
          set_has_heightcm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_countryCode;
        break;
      }

      // optional int32 countryCode = 8;
      case 8: {
        if (tag == 64) {
         parse_countryCode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &countrycode_)));
          set_has_countrycode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Landmark)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Landmark)
  return false;
#undef DO_
}

void Landmark::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Landmark)
  // optional .Geometry geometry = 1;
  if (has_geometry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->geometry(), output);
  }

  // optional int32 lateralOffset = 2;
  if (has_lateraloffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lateraloffset(), output);
  }

  // optional .LandmarkType type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional .ShapeType shapeType = 4;
  if (has_shapetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->shapetype(), output);
  }

  // optional int32 colorRgb = 5;
  if (has_colorrgb()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->colorrgb(), output);
  }

  // optional float widthCm = 6;
  if (has_widthcm()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->widthcm(), output);
  }

  // optional float heightCm = 7;
  if (has_heightcm()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->heightcm(), output);
  }

  // optional int32 countryCode = 8;
  if (has_countrycode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->countrycode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Landmark)
}

::google::protobuf::uint8* Landmark::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Landmark)
  // optional .Geometry geometry = 1;
  if (has_geometry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->geometry(), target);
  }

  // optional int32 lateralOffset = 2;
  if (has_lateraloffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lateraloffset(), target);
  }

  // optional .LandmarkType type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // optional .ShapeType shapeType = 4;
  if (has_shapetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->shapetype(), target);
  }

  // optional int32 colorRgb = 5;
  if (has_colorrgb()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->colorrgb(), target);
  }

  // optional float widthCm = 6;
  if (has_widthcm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->widthcm(), target);
  }

  // optional float heightCm = 7;
  if (has_heightcm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->heightcm(), target);
  }

  // optional int32 countryCode = 8;
  if (has_countrycode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->countrycode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Landmark)
  return target;
}

int Landmark::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Geometry geometry = 1;
    if (has_geometry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->geometry());
    }

    // optional int32 lateralOffset = 2;
    if (has_lateraloffset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lateraloffset());
    }

    // optional .LandmarkType type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .ShapeType shapeType = 4;
    if (has_shapetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->shapetype());
    }

    // optional int32 colorRgb = 5;
    if (has_colorrgb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->colorrgb());
    }

    // optional float widthCm = 6;
    if (has_widthcm()) {
      total_size += 1 + 4;
    }

    // optional float heightCm = 7;
    if (has_heightcm()) {
      total_size += 1 + 4;
    }

    // optional int32 countryCode = 8;
    if (has_countrycode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->countrycode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Landmark::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Landmark* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Landmark*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Landmark::MergeFrom(const Landmark& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_geometry()) {
      mutable_geometry()->::Geometry::MergeFrom(from.geometry());
    }
    if (from.has_lateraloffset()) {
      set_lateraloffset(from.lateraloffset());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_shapetype()) {
      set_shapetype(from.shapetype());
    }
    if (from.has_colorrgb()) {
      set_colorrgb(from.colorrgb());
    }
    if (from.has_widthcm()) {
      set_widthcm(from.widthcm());
    }
    if (from.has_heightcm()) {
      set_heightcm(from.heightcm());
    }
    if (from.has_countrycode()) {
      set_countrycode(from.countrycode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Landmark::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Landmark::CopyFrom(const Landmark& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Landmark::IsInitialized() const {

  return true;
}

void Landmark::Swap(Landmark* other) {
  if (other != this) {
    std::swap(geometry_, other->geometry_);
    std::swap(lateraloffset_, other->lateraloffset_);
    std::swap(type_, other->type_);
    std::swap(shapetype_, other->shapetype_);
    std::swap(colorrgb_, other->colorrgb_);
    std::swap(widthcm_, other->widthcm_);
    std::swap(heightcm_, other->heightcm_);
    std::swap(countrycode_, other->countrycode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Landmark::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Landmark_descriptor_;
  metadata.reflection = Landmark_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Lane::kCenterLineFieldNumber;
const int Lane::kTypeFieldNumber;
const int Lane::kLaneIdFieldNumber;
const int Lane::kPredecessorLaneIdsFieldNumber;
const int Lane::kPredecessorSectionIdFieldNumber;
#endif  // !_MSC_VER

Lane::Lane()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Lane)
}

void Lane::InitAsDefaultInstance() {
  centerline_ = const_cast< ::Geometry*>(&::Geometry::default_instance());
}

Lane::Lane(const Lane& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Lane)
}

void Lane::SharedCtor() {
  _cached_size_ = 0;
  centerline_ = NULL;
  type_ = 0;
  laneid_ = 0u;
  predecessorsectionid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Lane::~Lane() {
  // @@protoc_insertion_point(destructor:Lane)
  SharedDtor();
}

void Lane::SharedDtor() {
  if (this != default_instance_) {
    delete centerline_;
  }
}

void Lane::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Lane::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Lane_descriptor_;
}

const Lane& Lane::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RoadSection_2eproto();
  return *default_instance_;
}

Lane* Lane::default_instance_ = NULL;

Lane* Lane::New() const {
  return new Lane;
}

void Lane::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Lane*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 23) {
    ZR_(type_, laneid_);
    if (has_centerline()) {
      if (centerline_ != NULL) centerline_->::Geometry::Clear();
    }
    predecessorsectionid_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  predecessorlaneids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Lane::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Lane)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Geometry centerLine = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_centerline()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .LaneType type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::LaneType_IsValid(value)) {
            set_type(static_cast< ::LaneType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_laneId;
        break;
      }

      // optional uint32 laneId = 3;
      case 3: {
        if (tag == 24) {
         parse_laneId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &laneid_)));
          set_has_laneid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_predecessorLaneIds;
        break;
      }

      // repeated uint32 predecessorLaneIds = 4;
      case 4: {
        if (tag == 32) {
         parse_predecessorLaneIds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_predecessorlaneids())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_predecessorlaneids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_predecessorLaneIds;
        if (input->ExpectTag(40)) goto parse_predecessorSectionId;
        break;
      }

      // optional uint32 predecessorSectionId = 5;
      case 5: {
        if (tag == 40) {
         parse_predecessorSectionId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &predecessorsectionid_)));
          set_has_predecessorsectionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Lane)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Lane)
  return false;
#undef DO_
}

void Lane::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Lane)
  // optional .Geometry centerLine = 1;
  if (has_centerline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->centerline(), output);
  }

  // optional .LaneType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional uint32 laneId = 3;
  if (has_laneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->laneid(), output);
  }

  // repeated uint32 predecessorLaneIds = 4;
  for (int i = 0; i < this->predecessorlaneids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->predecessorlaneids(i), output);
  }

  // optional uint32 predecessorSectionId = 5;
  if (has_predecessorsectionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->predecessorsectionid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Lane)
}

::google::protobuf::uint8* Lane::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Lane)
  // optional .Geometry centerLine = 1;
  if (has_centerline()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->centerline(), target);
  }

  // optional .LaneType type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional uint32 laneId = 3;
  if (has_laneid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->laneid(), target);
  }

  // repeated uint32 predecessorLaneIds = 4;
  for (int i = 0; i < this->predecessorlaneids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(4, this->predecessorlaneids(i), target);
  }

  // optional uint32 predecessorSectionId = 5;
  if (has_predecessorsectionid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->predecessorsectionid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Lane)
  return target;
}

int Lane::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Geometry centerLine = 1;
    if (has_centerline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->centerline());
    }

    // optional .LaneType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 laneId = 3;
    if (has_laneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->laneid());
    }

    // optional uint32 predecessorSectionId = 5;
    if (has_predecessorsectionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->predecessorsectionid());
    }

  }
  // repeated uint32 predecessorLaneIds = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->predecessorlaneids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->predecessorlaneids(i));
    }
    total_size += 1 * this->predecessorlaneids_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Lane::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Lane* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Lane*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Lane::MergeFrom(const Lane& from) {
  GOOGLE_CHECK_NE(&from, this);
  predecessorlaneids_.MergeFrom(from.predecessorlaneids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_centerline()) {
      mutable_centerline()->::Geometry::MergeFrom(from.centerline());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_laneid()) {
      set_laneid(from.laneid());
    }
    if (from.has_predecessorsectionid()) {
      set_predecessorsectionid(from.predecessorsectionid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Lane::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Lane::CopyFrom(const Lane& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lane::IsInitialized() const {

  return true;
}

void Lane::Swap(Lane* other) {
  if (other != this) {
    std::swap(centerline_, other->centerline_);
    std::swap(type_, other->type_);
    std::swap(laneid_, other->laneid_);
    predecessorlaneids_.Swap(&other->predecessorlaneids_);
    std::swap(predecessorsectionid_, other->predecessorsectionid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Lane::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Lane_descriptor_;
  metadata.reflection = Lane_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LaneBoundary::kGeometryFieldNumber;
const int LaneBoundary::kTypeFieldNumber;
#endif  // !_MSC_VER

LaneBoundary::LaneBoundary()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:LaneBoundary)
}

void LaneBoundary::InitAsDefaultInstance() {
  geometry_ = const_cast< ::Geometry*>(&::Geometry::default_instance());
}

LaneBoundary::LaneBoundary(const LaneBoundary& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:LaneBoundary)
}

void LaneBoundary::SharedCtor() {
  _cached_size_ = 0;
  geometry_ = NULL;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaneBoundary::~LaneBoundary() {
  // @@protoc_insertion_point(destructor:LaneBoundary)
  SharedDtor();
}

void LaneBoundary::SharedDtor() {
  if (this != default_instance_) {
    delete geometry_;
  }
}

void LaneBoundary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaneBoundary::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaneBoundary_descriptor_;
}

const LaneBoundary& LaneBoundary::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RoadSection_2eproto();
  return *default_instance_;
}

LaneBoundary* LaneBoundary::default_instance_ = NULL;

LaneBoundary* LaneBoundary::New() const {
  return new LaneBoundary;
}

void LaneBoundary::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_geometry()) {
      if (geometry_ != NULL) geometry_->::Geometry::Clear();
    }
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LaneBoundary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:LaneBoundary)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Geometry geometry = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_geometry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .LaneBoundaryType type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::LaneBoundaryType_IsValid(value)) {
            set_type(static_cast< ::LaneBoundaryType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:LaneBoundary)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:LaneBoundary)
  return false;
#undef DO_
}

void LaneBoundary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:LaneBoundary)
  // optional .Geometry geometry = 1;
  if (has_geometry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->geometry(), output);
  }

  // optional .LaneBoundaryType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:LaneBoundary)
}

::google::protobuf::uint8* LaneBoundary::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:LaneBoundary)
  // optional .Geometry geometry = 1;
  if (has_geometry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->geometry(), target);
  }

  // optional .LaneBoundaryType type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LaneBoundary)
  return target;
}

int LaneBoundary::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Geometry geometry = 1;
    if (has_geometry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->geometry());
    }

    // optional .LaneBoundaryType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaneBoundary::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LaneBoundary* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LaneBoundary*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LaneBoundary::MergeFrom(const LaneBoundary& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_geometry()) {
      mutable_geometry()->::Geometry::MergeFrom(from.geometry());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LaneBoundary::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneBoundary::CopyFrom(const LaneBoundary& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneBoundary::IsInitialized() const {

  return true;
}

void LaneBoundary::Swap(LaneBoundary* other) {
  if (other != this) {
    std::swap(geometry_, other->geometry_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LaneBoundary::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaneBoundary_descriptor_;
  metadata.reflection = LaneBoundary_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LaneModel::kLanesFieldNumber;
const int LaneModel::kBoundariesFieldNumber;
#endif  // !_MSC_VER

LaneModel::LaneModel()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:LaneModel)
}

void LaneModel::InitAsDefaultInstance() {
}

LaneModel::LaneModel(const LaneModel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:LaneModel)
}

void LaneModel::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaneModel::~LaneModel() {
  // @@protoc_insertion_point(destructor:LaneModel)
  SharedDtor();
}

void LaneModel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LaneModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaneModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaneModel_descriptor_;
}

const LaneModel& LaneModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RoadSection_2eproto();
  return *default_instance_;
}

LaneModel* LaneModel::default_instance_ = NULL;

LaneModel* LaneModel::New() const {
  return new LaneModel;
}

void LaneModel::Clear() {
  lanes_.Clear();
  boundaries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LaneModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:LaneModel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Lane lanes = 1;
      case 1: {
        if (tag == 10) {
         parse_lanes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lanes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_lanes;
        if (input->ExpectTag(18)) goto parse_boundaries;
        break;
      }

      // repeated .LaneBoundary boundaries = 2;
      case 2: {
        if (tag == 18) {
         parse_boundaries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_boundaries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_boundaries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:LaneModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:LaneModel)
  return false;
#undef DO_
}

void LaneModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:LaneModel)
  // repeated .Lane lanes = 1;
  for (int i = 0; i < this->lanes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->lanes(i), output);
  }

  // repeated .LaneBoundary boundaries = 2;
  for (int i = 0; i < this->boundaries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->boundaries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:LaneModel)
}

::google::protobuf::uint8* LaneModel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:LaneModel)
  // repeated .Lane lanes = 1;
  for (int i = 0; i < this->lanes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->lanes(i), target);
  }

  // repeated .LaneBoundary boundaries = 2;
  for (int i = 0; i < this->boundaries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->boundaries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LaneModel)
  return target;
}

int LaneModel::ByteSize() const {
  int total_size = 0;

  // repeated .Lane lanes = 1;
  total_size += 1 * this->lanes_size();
  for (int i = 0; i < this->lanes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lanes(i));
  }

  // repeated .LaneBoundary boundaries = 2;
  total_size += 1 * this->boundaries_size();
  for (int i = 0; i < this->boundaries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->boundaries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaneModel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LaneModel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LaneModel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LaneModel::MergeFrom(const LaneModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  lanes_.MergeFrom(from.lanes_);
  boundaries_.MergeFrom(from.boundaries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LaneModel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneModel::CopyFrom(const LaneModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneModel::IsInitialized() const {

  return true;
}

void LaneModel::Swap(LaneModel* other) {
  if (other != this) {
    lanes_.Swap(&other->lanes_);
    boundaries_.Swap(&other->boundaries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LaneModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaneModel_descriptor_;
  metadata.reflection = LaneModel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RoadSection::kSectionIdFieldNumber;
const int RoadSection::kLaneModelFieldNumber;
const int RoadSection::kLandmarksFieldNumber;
const int RoadSection::kRoadSectionCenterLineFieldNumber;
#endif  // !_MSC_VER

RoadSection::RoadSection()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RoadSection)
}

void RoadSection::InitAsDefaultInstance() {
  lanemodel_ = const_cast< ::LaneModel*>(&::LaneModel::default_instance());
  roadsectioncenterline_ = const_cast< ::Geometry*>(&::Geometry::default_instance());
}

RoadSection::RoadSection(const RoadSection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RoadSection)
}

void RoadSection::SharedCtor() {
  _cached_size_ = 0;
  sectionid_ = 0u;
  lanemodel_ = NULL;
  roadsectioncenterline_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoadSection::~RoadSection() {
  // @@protoc_insertion_point(destructor:RoadSection)
  SharedDtor();
}

void RoadSection::SharedDtor() {
  if (this != default_instance_) {
    delete lanemodel_;
    delete roadsectioncenterline_;
  }
}

void RoadSection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadSection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoadSection_descriptor_;
}

const RoadSection& RoadSection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RoadSection_2eproto();
  return *default_instance_;
}

RoadSection* RoadSection::default_instance_ = NULL;

RoadSection* RoadSection::New() const {
  return new RoadSection;
}

void RoadSection::Clear() {
  if (_has_bits_[0 / 32] & 11) {
    sectionid_ = 0u;
    if (has_lanemodel()) {
      if (lanemodel_ != NULL) lanemodel_->::LaneModel::Clear();
    }
    if (has_roadsectioncenterline()) {
      if (roadsectioncenterline_ != NULL) roadsectioncenterline_->::Geometry::Clear();
    }
  }
  landmarks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RoadSection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RoadSection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sectionId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sectionid_)));
          set_has_sectionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_laneModel;
        break;
      }

      // optional .LaneModel laneModel = 2;
      case 2: {
        if (tag == 18) {
         parse_laneModel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lanemodel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_landmarks;
        break;
      }

      // repeated .Landmark landmarks = 3;
      case 3: {
        if (tag == 26) {
         parse_landmarks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_landmarks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_landmarks;
        if (input->ExpectTag(34)) goto parse_roadSectionCenterLine;
        break;
      }

      // optional .Geometry roadSectionCenterLine = 4;
      case 4: {
        if (tag == 34) {
         parse_roadSectionCenterLine:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_roadsectioncenterline()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RoadSection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RoadSection)
  return false;
#undef DO_
}

void RoadSection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RoadSection)
  // optional uint32 sectionId = 1;
  if (has_sectionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sectionid(), output);
  }

  // optional .LaneModel laneModel = 2;
  if (has_lanemodel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->lanemodel(), output);
  }

  // repeated .Landmark landmarks = 3;
  for (int i = 0; i < this->landmarks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->landmarks(i), output);
  }

  // optional .Geometry roadSectionCenterLine = 4;
  if (has_roadsectioncenterline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->roadsectioncenterline(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RoadSection)
}

::google::protobuf::uint8* RoadSection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadSection)
  // optional uint32 sectionId = 1;
  if (has_sectionid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sectionid(), target);
  }

  // optional .LaneModel laneModel = 2;
  if (has_lanemodel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->lanemodel(), target);
  }

  // repeated .Landmark landmarks = 3;
  for (int i = 0; i < this->landmarks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->landmarks(i), target);
  }

  // optional .Geometry roadSectionCenterLine = 4;
  if (has_roadsectioncenterline()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->roadsectioncenterline(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadSection)
  return target;
}

int RoadSection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 sectionId = 1;
    if (has_sectionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sectionid());
    }

    // optional .LaneModel laneModel = 2;
    if (has_lanemodel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lanemodel());
    }

    // optional .Geometry roadSectionCenterLine = 4;
    if (has_roadsectioncenterline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->roadsectioncenterline());
    }

  }
  // repeated .Landmark landmarks = 3;
  total_size += 1 * this->landmarks_size();
  for (int i = 0; i < this->landmarks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->landmarks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadSection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RoadSection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RoadSection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RoadSection::MergeFrom(const RoadSection& from) {
  GOOGLE_CHECK_NE(&from, this);
  landmarks_.MergeFrom(from.landmarks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sectionid()) {
      set_sectionid(from.sectionid());
    }
    if (from.has_lanemodel()) {
      mutable_lanemodel()->::LaneModel::MergeFrom(from.lanemodel());
    }
    if (from.has_roadsectioncenterline()) {
      mutable_roadsectioncenterline()->::Geometry::MergeFrom(from.roadsectioncenterline());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RoadSection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadSection::CopyFrom(const RoadSection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadSection::IsInitialized() const {

  return true;
}

void RoadSection::Swap(RoadSection* other) {
  if (other != this) {
    std::swap(sectionid_, other->sectionid_);
    std::swap(lanemodel_, other->lanemodel_);
    landmarks_.Swap(&other->landmarks_);
    std::swap(roadsectioncenterline_, other->roadsectioncenterline_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RoadSection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RoadSection_descriptor_;
  metadata.reflection = RoadSection_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RoadSections::kRoadSectionsFieldNumber;
#endif  // !_MSC_VER

RoadSections::RoadSections()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RoadSections)
}

void RoadSections::InitAsDefaultInstance() {
}

RoadSections::RoadSections(const RoadSections& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RoadSections)
}

void RoadSections::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoadSections::~RoadSections() {
  // @@protoc_insertion_point(destructor:RoadSections)
  SharedDtor();
}

void RoadSections::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RoadSections::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadSections::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoadSections_descriptor_;
}

const RoadSections& RoadSections::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RoadSection_2eproto();
  return *default_instance_;
}

RoadSections* RoadSections::default_instance_ = NULL;

RoadSections* RoadSections::New() const {
  return new RoadSections;
}

void RoadSections::Clear() {
  roadsections_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RoadSections::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RoadSections)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .RoadSection roadSections = 1;
      case 1: {
        if (tag == 10) {
         parse_roadSections:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_roadsections()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_roadSections;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RoadSections)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RoadSections)
  return false;
#undef DO_
}

void RoadSections::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RoadSections)
  // repeated .RoadSection roadSections = 1;
  for (int i = 0; i < this->roadsections_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->roadsections(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RoadSections)
}

::google::protobuf::uint8* RoadSections::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoadSections)
  // repeated .RoadSection roadSections = 1;
  for (int i = 0; i < this->roadsections_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->roadsections(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoadSections)
  return target;
}

int RoadSections::ByteSize() const {
  int total_size = 0;

  // repeated .RoadSection roadSections = 1;
  total_size += 1 * this->roadsections_size();
  for (int i = 0; i < this->roadsections_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->roadsections(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadSections::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RoadSections* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RoadSections*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RoadSections::MergeFrom(const RoadSections& from) {
  GOOGLE_CHECK_NE(&from, this);
  roadsections_.MergeFrom(from.roadsections_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RoadSections::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadSections::CopyFrom(const RoadSections& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadSections::IsInitialized() const {

  return true;
}

void RoadSections::Swap(RoadSections* other) {
  if (other != this) {
    roadsections_.Swap(&other->roadsections_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RoadSections::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RoadSections_descriptor_;
  metadata.reflection = RoadSections_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
