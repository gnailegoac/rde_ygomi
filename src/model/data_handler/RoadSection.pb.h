// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RoadSection.proto

#ifndef PROTOBUF_RoadSection_2eproto__INCLUDED
#define PROTOBUF_RoadSection_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RoadSection_2eproto();
void protobuf_AssignDesc_RoadSection_2eproto();
void protobuf_ShutdownFile_RoadSection_2eproto();

class GeometryPoint;
class Geometry;
class Landmark;
class Lane;
class LaneBoundary;
class LaneModel;
class RoadSection;
class RoadSections;

enum ShapeType {
  SHAPETYPE_UNKNOWN = 0,
  SHAPETYPE_CIRCLE = 1,
  SHAPETYPE_RECTANGLE = 2,
  SHAPETYPE_DIAMOND = 3,
  SHAPETYPE_TRIANGLE = 4
};
bool ShapeType_IsValid(int value);
const ShapeType ShapeType_MIN = SHAPETYPE_UNKNOWN;
const ShapeType ShapeType_MAX = SHAPETYPE_TRIANGLE;
const int ShapeType_ARRAYSIZE = ShapeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShapeType_descriptor();
inline const ::std::string& ShapeType_Name(ShapeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShapeType_descriptor(), value);
}
inline bool ShapeType_Parse(
    const ::std::string& name, ShapeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeType>(
    ShapeType_descriptor(), name, value);
}
enum LandmarkType {
  LANDMARKTYPE_UNKNOWN = 0,
  LANDMARKTYPE_TRAFFICSIGN = 1,
  LANDMARKTYPE_GUARDRAIL = 2,
  LANDMARKTYPE_CURB = 3
};
bool LandmarkType_IsValid(int value);
const LandmarkType LandmarkType_MIN = LANDMARKTYPE_UNKNOWN;
const LandmarkType LandmarkType_MAX = LANDMARKTYPE_CURB;
const int LandmarkType_ARRAYSIZE = LandmarkType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LandmarkType_descriptor();
inline const ::std::string& LandmarkType_Name(LandmarkType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LandmarkType_descriptor(), value);
}
inline bool LandmarkType_Parse(
    const ::std::string& name, LandmarkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LandmarkType>(
    LandmarkType_descriptor(), name, value);
}
enum LaneType {
  LANETYPE_UNKNOWN = 0,
  LANETYPE_NORMAL = 1,
  LANETYPE_SHOULDER = 2,
  LANETYPE_ENTRY = 3,
  LANETYPE_EXIT = 4,
  LANETYPE_RAMP = 5
};
bool LaneType_IsValid(int value);
const LaneType LaneType_MIN = LANETYPE_UNKNOWN;
const LaneType LaneType_MAX = LANETYPE_RAMP;
const int LaneType_ARRAYSIZE = LaneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneType_descriptor();
inline const ::std::string& LaneType_Name(LaneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneType_descriptor(), value);
}
inline bool LaneType_Parse(
    const ::std::string& name, LaneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneType>(
    LaneType_descriptor(), name, value);
}
enum LaneBoundaryType {
  LANEBOUNDARYTYPE_UNKNOWN = 0,
  LANEBOUNDARYTYPE_MARKING_DASHED = 1,
  LANEBOUNDARYTYPE_MARKING_SOLID = 2,
  LANEBOUNDARYTYPE_MARKING_DOUBLE = 3,
  LANEBOUNDARYTYPE_MARKING_BOTTS_DOTS = 4,
  LANEBOUNDARYTYPE_MARKING_BLOCK = 5,
  LANEBOUNDARYTYPE_MARKING_NONE = 6
};
bool LaneBoundaryType_IsValid(int value);
const LaneBoundaryType LaneBoundaryType_MIN = LANEBOUNDARYTYPE_UNKNOWN;
const LaneBoundaryType LaneBoundaryType_MAX = LANEBOUNDARYTYPE_MARKING_NONE;
const int LaneBoundaryType_ARRAYSIZE = LaneBoundaryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundaryType_descriptor();
inline const ::std::string& LaneBoundaryType_Name(LaneBoundaryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundaryType_descriptor(), value);
}
inline bool LaneBoundaryType_Parse(
    const ::std::string& name, LaneBoundaryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundaryType>(
    LaneBoundaryType_descriptor(), name, value);
}
// ===================================================================

class GeometryPoint : public ::google::protobuf::Message {
 public:
  GeometryPoint();
  virtual ~GeometryPoint();

  GeometryPoint(const GeometryPoint& from);

  inline GeometryPoint& operator=(const GeometryPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeometryPoint& default_instance();

  void Swap(GeometryPoint* other);

  // implements Message ----------------------------------------------

  GeometryPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeometryPoint& from);
  void MergeFrom(const GeometryPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline double lon() const;
  inline void set_lon(double value);

  // optional double height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline double height() const;
  inline void set_height(double value);

  // @@protoc_insertion_point(class_scope:GeometryPoint)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double lat_;
  double lon_;
  double height_;
  friend void  protobuf_AddDesc_RoadSection_2eproto();
  friend void protobuf_AssignDesc_RoadSection_2eproto();
  friend void protobuf_ShutdownFile_RoadSection_2eproto();

  void InitAsDefaultInstance();
  static GeometryPoint* default_instance_;
};
// -------------------------------------------------------------------

class Geometry : public ::google::protobuf::Message {
 public:
  Geometry();
  virtual ~Geometry();

  Geometry(const Geometry& from);

  inline Geometry& operator=(const Geometry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geometry& default_instance();

  void Swap(Geometry* other);

  // implements Message ----------------------------------------------

  Geometry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Geometry& from);
  void MergeFrom(const Geometry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .GeometryPoint points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::GeometryPoint& points(int index) const;
  inline ::GeometryPoint* mutable_points(int index);
  inline ::GeometryPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::GeometryPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::GeometryPoint >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:Geometry)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::GeometryPoint > points_;
  friend void  protobuf_AddDesc_RoadSection_2eproto();
  friend void protobuf_AssignDesc_RoadSection_2eproto();
  friend void protobuf_ShutdownFile_RoadSection_2eproto();

  void InitAsDefaultInstance();
  static Geometry* default_instance_;
};
// -------------------------------------------------------------------

class Landmark : public ::google::protobuf::Message {
 public:
  Landmark();
  virtual ~Landmark();

  Landmark(const Landmark& from);

  inline Landmark& operator=(const Landmark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Landmark& default_instance();

  void Swap(Landmark* other);

  // implements Message ----------------------------------------------

  Landmark* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Landmark& from);
  void MergeFrom(const Landmark& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Geometry geometry = 1;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  inline const ::Geometry& geometry() const;
  inline ::Geometry* mutable_geometry();
  inline ::Geometry* release_geometry();
  inline void set_allocated_geometry(::Geometry* geometry);

  // optional int32 lateralOffset = 2;
  inline bool has_lateraloffset() const;
  inline void clear_lateraloffset();
  static const int kLateralOffsetFieldNumber = 2;
  inline ::google::protobuf::int32 lateraloffset() const;
  inline void set_lateraloffset(::google::protobuf::int32 value);

  // optional .LandmarkType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::LandmarkType type() const;
  inline void set_type(::LandmarkType value);

  // optional .ShapeType shapeType = 4;
  inline bool has_shapetype() const;
  inline void clear_shapetype();
  static const int kShapeTypeFieldNumber = 4;
  inline ::ShapeType shapetype() const;
  inline void set_shapetype(::ShapeType value);

  // optional int32 colorRgb = 5;
  inline bool has_colorrgb() const;
  inline void clear_colorrgb();
  static const int kColorRgbFieldNumber = 5;
  inline ::google::protobuf::int32 colorrgb() const;
  inline void set_colorrgb(::google::protobuf::int32 value);

  // optional float widthCm = 6;
  inline bool has_widthcm() const;
  inline void clear_widthcm();
  static const int kWidthCmFieldNumber = 6;
  inline float widthcm() const;
  inline void set_widthcm(float value);

  // optional float heightCm = 7;
  inline bool has_heightcm() const;
  inline void clear_heightcm();
  static const int kHeightCmFieldNumber = 7;
  inline float heightcm() const;
  inline void set_heightcm(float value);

  // optional int32 countryCode = 8;
  inline bool has_countrycode() const;
  inline void clear_countrycode();
  static const int kCountryCodeFieldNumber = 8;
  inline ::google::protobuf::int32 countrycode() const;
  inline void set_countrycode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Landmark)
 private:
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_lateraloffset();
  inline void clear_has_lateraloffset();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_shapetype();
  inline void clear_has_shapetype();
  inline void set_has_colorrgb();
  inline void clear_has_colorrgb();
  inline void set_has_widthcm();
  inline void clear_has_widthcm();
  inline void set_has_heightcm();
  inline void clear_has_heightcm();
  inline void set_has_countrycode();
  inline void clear_has_countrycode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Geometry* geometry_;
  ::google::protobuf::int32 lateraloffset_;
  int type_;
  int shapetype_;
  ::google::protobuf::int32 colorrgb_;
  float widthcm_;
  float heightcm_;
  ::google::protobuf::int32 countrycode_;
  friend void  protobuf_AddDesc_RoadSection_2eproto();
  friend void protobuf_AssignDesc_RoadSection_2eproto();
  friend void protobuf_ShutdownFile_RoadSection_2eproto();

  void InitAsDefaultInstance();
  static Landmark* default_instance_;
};
// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  void Swap(Lane* other);

  // implements Message ----------------------------------------------

  Lane* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Geometry centerLine = 1;
  inline bool has_centerline() const;
  inline void clear_centerline();
  static const int kCenterLineFieldNumber = 1;
  inline const ::Geometry& centerline() const;
  inline ::Geometry* mutable_centerline();
  inline ::Geometry* release_centerline();
  inline void set_allocated_centerline(::Geometry* centerline);

  // optional .LaneType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::LaneType type() const;
  inline void set_type(::LaneType value);

  // optional uint32 laneId = 3;
  inline bool has_laneid() const;
  inline void clear_laneid();
  static const int kLaneIdFieldNumber = 3;
  inline ::google::protobuf::uint32 laneid() const;
  inline void set_laneid(::google::protobuf::uint32 value);

  // repeated uint32 predecessorLaneIds = 4;
  inline int predecessorlaneids_size() const;
  inline void clear_predecessorlaneids();
  static const int kPredecessorLaneIdsFieldNumber = 4;
  inline ::google::protobuf::uint32 predecessorlaneids(int index) const;
  inline void set_predecessorlaneids(int index, ::google::protobuf::uint32 value);
  inline void add_predecessorlaneids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      predecessorlaneids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_predecessorlaneids();

  // optional uint32 predecessorSectionId = 5;
  inline bool has_predecessorsectionid() const;
  inline void clear_predecessorsectionid();
  static const int kPredecessorSectionIdFieldNumber = 5;
  inline ::google::protobuf::uint32 predecessorsectionid() const;
  inline void set_predecessorsectionid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Lane)
 private:
  inline void set_has_centerline();
  inline void clear_has_centerline();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_laneid();
  inline void clear_has_laneid();
  inline void set_has_predecessorsectionid();
  inline void clear_has_predecessorsectionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Geometry* centerline_;
  int type_;
  ::google::protobuf::uint32 laneid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > predecessorlaneids_;
  ::google::protobuf::uint32 predecessorsectionid_;
  friend void  protobuf_AddDesc_RoadSection_2eproto();
  friend void protobuf_AssignDesc_RoadSection_2eproto();
  friend void protobuf_ShutdownFile_RoadSection_2eproto();

  void InitAsDefaultInstance();
  static Lane* default_instance_;
};
// -------------------------------------------------------------------

class LaneBoundary : public ::google::protobuf::Message {
 public:
  LaneBoundary();
  virtual ~LaneBoundary();

  LaneBoundary(const LaneBoundary& from);

  inline LaneBoundary& operator=(const LaneBoundary& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundary& default_instance();

  void Swap(LaneBoundary* other);

  // implements Message ----------------------------------------------

  LaneBoundary* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaneBoundary& from);
  void MergeFrom(const LaneBoundary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Geometry geometry = 1;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  inline const ::Geometry& geometry() const;
  inline ::Geometry* mutable_geometry();
  inline ::Geometry* release_geometry();
  inline void set_allocated_geometry(::Geometry* geometry);

  // optional .LaneBoundaryType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::LaneBoundaryType type() const;
  inline void set_type(::LaneBoundaryType value);

  // @@protoc_insertion_point(class_scope:LaneBoundary)
 private:
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Geometry* geometry_;
  int type_;
  friend void  protobuf_AddDesc_RoadSection_2eproto();
  friend void protobuf_AssignDesc_RoadSection_2eproto();
  friend void protobuf_ShutdownFile_RoadSection_2eproto();

  void InitAsDefaultInstance();
  static LaneBoundary* default_instance_;
};
// -------------------------------------------------------------------

class LaneModel : public ::google::protobuf::Message {
 public:
  LaneModel();
  virtual ~LaneModel();

  LaneModel(const LaneModel& from);

  inline LaneModel& operator=(const LaneModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneModel& default_instance();

  void Swap(LaneModel* other);

  // implements Message ----------------------------------------------

  LaneModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaneModel& from);
  void MergeFrom(const LaneModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Lane lanes = 1;
  inline int lanes_size() const;
  inline void clear_lanes();
  static const int kLanesFieldNumber = 1;
  inline const ::Lane& lanes(int index) const;
  inline ::Lane* mutable_lanes(int index);
  inline ::Lane* add_lanes();
  inline const ::google::protobuf::RepeatedPtrField< ::Lane >&
      lanes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lane >*
      mutable_lanes();

  // repeated .LaneBoundary boundaries = 2;
  inline int boundaries_size() const;
  inline void clear_boundaries();
  static const int kBoundariesFieldNumber = 2;
  inline const ::LaneBoundary& boundaries(int index) const;
  inline ::LaneBoundary* mutable_boundaries(int index);
  inline ::LaneBoundary* add_boundaries();
  inline const ::google::protobuf::RepeatedPtrField< ::LaneBoundary >&
      boundaries() const;
  inline ::google::protobuf::RepeatedPtrField< ::LaneBoundary >*
      mutable_boundaries();

  // @@protoc_insertion_point(class_scope:LaneModel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Lane > lanes_;
  ::google::protobuf::RepeatedPtrField< ::LaneBoundary > boundaries_;
  friend void  protobuf_AddDesc_RoadSection_2eproto();
  friend void protobuf_AssignDesc_RoadSection_2eproto();
  friend void protobuf_ShutdownFile_RoadSection_2eproto();

  void InitAsDefaultInstance();
  static LaneModel* default_instance_;
};
// -------------------------------------------------------------------

class RoadSection : public ::google::protobuf::Message {
 public:
  RoadSection();
  virtual ~RoadSection();

  RoadSection(const RoadSection& from);

  inline RoadSection& operator=(const RoadSection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadSection& default_instance();

  void Swap(RoadSection* other);

  // implements Message ----------------------------------------------

  RoadSection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoadSection& from);
  void MergeFrom(const RoadSection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sectionId = 1;
  inline bool has_sectionid() const;
  inline void clear_sectionid();
  static const int kSectionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 sectionid() const;
  inline void set_sectionid(::google::protobuf::uint32 value);

  // optional .LaneModel laneModel = 2;
  inline bool has_lanemodel() const;
  inline void clear_lanemodel();
  static const int kLaneModelFieldNumber = 2;
  inline const ::LaneModel& lanemodel() const;
  inline ::LaneModel* mutable_lanemodel();
  inline ::LaneModel* release_lanemodel();
  inline void set_allocated_lanemodel(::LaneModel* lanemodel);

  // repeated .Landmark landmarks = 3;
  inline int landmarks_size() const;
  inline void clear_landmarks();
  static const int kLandmarksFieldNumber = 3;
  inline const ::Landmark& landmarks(int index) const;
  inline ::Landmark* mutable_landmarks(int index);
  inline ::Landmark* add_landmarks();
  inline const ::google::protobuf::RepeatedPtrField< ::Landmark >&
      landmarks() const;
  inline ::google::protobuf::RepeatedPtrField< ::Landmark >*
      mutable_landmarks();

  // optional .Geometry roadSectionCenterLine = 4;
  inline bool has_roadsectioncenterline() const;
  inline void clear_roadsectioncenterline();
  static const int kRoadSectionCenterLineFieldNumber = 4;
  inline const ::Geometry& roadsectioncenterline() const;
  inline ::Geometry* mutable_roadsectioncenterline();
  inline ::Geometry* release_roadsectioncenterline();
  inline void set_allocated_roadsectioncenterline(::Geometry* roadsectioncenterline);

  // @@protoc_insertion_point(class_scope:RoadSection)
 private:
  inline void set_has_sectionid();
  inline void clear_has_sectionid();
  inline void set_has_lanemodel();
  inline void clear_has_lanemodel();
  inline void set_has_roadsectioncenterline();
  inline void clear_has_roadsectioncenterline();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::LaneModel* lanemodel_;
  ::google::protobuf::RepeatedPtrField< ::Landmark > landmarks_;
  ::Geometry* roadsectioncenterline_;
  ::google::protobuf::uint32 sectionid_;
  friend void  protobuf_AddDesc_RoadSection_2eproto();
  friend void protobuf_AssignDesc_RoadSection_2eproto();
  friend void protobuf_ShutdownFile_RoadSection_2eproto();

  void InitAsDefaultInstance();
  static RoadSection* default_instance_;
};
// -------------------------------------------------------------------

class RoadSections : public ::google::protobuf::Message {
 public:
  RoadSections();
  virtual ~RoadSections();

  RoadSections(const RoadSections& from);

  inline RoadSections& operator=(const RoadSections& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadSections& default_instance();

  void Swap(RoadSections* other);

  // implements Message ----------------------------------------------

  RoadSections* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoadSections& from);
  void MergeFrom(const RoadSections& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RoadSection roadSections = 1;
  inline int roadsections_size() const;
  inline void clear_roadsections();
  static const int kRoadSectionsFieldNumber = 1;
  inline const ::RoadSection& roadsections(int index) const;
  inline ::RoadSection* mutable_roadsections(int index);
  inline ::RoadSection* add_roadsections();
  inline const ::google::protobuf::RepeatedPtrField< ::RoadSection >&
      roadsections() const;
  inline ::google::protobuf::RepeatedPtrField< ::RoadSection >*
      mutable_roadsections();

  // @@protoc_insertion_point(class_scope:RoadSections)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RoadSection > roadsections_;
  friend void  protobuf_AddDesc_RoadSection_2eproto();
  friend void protobuf_AssignDesc_RoadSection_2eproto();
  friend void protobuf_ShutdownFile_RoadSection_2eproto();

  void InitAsDefaultInstance();
  static RoadSections* default_instance_;
};
// ===================================================================


// ===================================================================

// GeometryPoint

// optional double lat = 1;
inline bool GeometryPoint::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeometryPoint::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeometryPoint::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeometryPoint::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double GeometryPoint::lat() const {
  // @@protoc_insertion_point(field_get:GeometryPoint.lat)
  return lat_;
}
inline void GeometryPoint::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:GeometryPoint.lat)
}

// optional double lon = 2;
inline bool GeometryPoint::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeometryPoint::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeometryPoint::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeometryPoint::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double GeometryPoint::lon() const {
  // @@protoc_insertion_point(field_get:GeometryPoint.lon)
  return lon_;
}
inline void GeometryPoint::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:GeometryPoint.lon)
}

// optional double height = 3;
inline bool GeometryPoint::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeometryPoint::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeometryPoint::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeometryPoint::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double GeometryPoint::height() const {
  // @@protoc_insertion_point(field_get:GeometryPoint.height)
  return height_;
}
inline void GeometryPoint::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:GeometryPoint.height)
}

// -------------------------------------------------------------------

// Geometry

// repeated .GeometryPoint points = 1;
inline int Geometry::points_size() const {
  return points_.size();
}
inline void Geometry::clear_points() {
  points_.Clear();
}
inline const ::GeometryPoint& Geometry::points(int index) const {
  // @@protoc_insertion_point(field_get:Geometry.points)
  return points_.Get(index);
}
inline ::GeometryPoint* Geometry::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:Geometry.points)
  return points_.Mutable(index);
}
inline ::GeometryPoint* Geometry::add_points() {
  // @@protoc_insertion_point(field_add:Geometry.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GeometryPoint >&
Geometry::points() const {
  // @@protoc_insertion_point(field_list:Geometry.points)
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::GeometryPoint >*
Geometry::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:Geometry.points)
  return &points_;
}

// -------------------------------------------------------------------

// Landmark

// optional .Geometry geometry = 1;
inline bool Landmark::has_geometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Landmark::set_has_geometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Landmark::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Landmark::clear_geometry() {
  if (geometry_ != NULL) geometry_->::Geometry::Clear();
  clear_has_geometry();
}
inline const ::Geometry& Landmark::geometry() const {
  // @@protoc_insertion_point(field_get:Landmark.geometry)
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::Geometry* Landmark::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::Geometry;
  // @@protoc_insertion_point(field_mutable:Landmark.geometry)
  return geometry_;
}
inline ::Geometry* Landmark::release_geometry() {
  clear_has_geometry();
  ::Geometry* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void Landmark::set_allocated_geometry(::Geometry* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
  // @@protoc_insertion_point(field_set_allocated:Landmark.geometry)
}

// optional int32 lateralOffset = 2;
inline bool Landmark::has_lateraloffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Landmark::set_has_lateraloffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Landmark::clear_has_lateraloffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Landmark::clear_lateraloffset() {
  lateraloffset_ = 0;
  clear_has_lateraloffset();
}
inline ::google::protobuf::int32 Landmark::lateraloffset() const {
  // @@protoc_insertion_point(field_get:Landmark.lateralOffset)
  return lateraloffset_;
}
inline void Landmark::set_lateraloffset(::google::protobuf::int32 value) {
  set_has_lateraloffset();
  lateraloffset_ = value;
  // @@protoc_insertion_point(field_set:Landmark.lateralOffset)
}

// optional .LandmarkType type = 3;
inline bool Landmark::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Landmark::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Landmark::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Landmark::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::LandmarkType Landmark::type() const {
  // @@protoc_insertion_point(field_get:Landmark.type)
  return static_cast< ::LandmarkType >(type_);
}
inline void Landmark::set_type(::LandmarkType value) {
  assert(::LandmarkType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Landmark.type)
}

// optional .ShapeType shapeType = 4;
inline bool Landmark::has_shapetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Landmark::set_has_shapetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Landmark::clear_has_shapetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Landmark::clear_shapetype() {
  shapetype_ = 0;
  clear_has_shapetype();
}
inline ::ShapeType Landmark::shapetype() const {
  // @@protoc_insertion_point(field_get:Landmark.shapeType)
  return static_cast< ::ShapeType >(shapetype_);
}
inline void Landmark::set_shapetype(::ShapeType value) {
  assert(::ShapeType_IsValid(value));
  set_has_shapetype();
  shapetype_ = value;
  // @@protoc_insertion_point(field_set:Landmark.shapeType)
}

// optional int32 colorRgb = 5;
inline bool Landmark::has_colorrgb() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Landmark::set_has_colorrgb() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Landmark::clear_has_colorrgb() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Landmark::clear_colorrgb() {
  colorrgb_ = 0;
  clear_has_colorrgb();
}
inline ::google::protobuf::int32 Landmark::colorrgb() const {
  // @@protoc_insertion_point(field_get:Landmark.colorRgb)
  return colorrgb_;
}
inline void Landmark::set_colorrgb(::google::protobuf::int32 value) {
  set_has_colorrgb();
  colorrgb_ = value;
  // @@protoc_insertion_point(field_set:Landmark.colorRgb)
}

// optional float widthCm = 6;
inline bool Landmark::has_widthcm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Landmark::set_has_widthcm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Landmark::clear_has_widthcm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Landmark::clear_widthcm() {
  widthcm_ = 0;
  clear_has_widthcm();
}
inline float Landmark::widthcm() const {
  // @@protoc_insertion_point(field_get:Landmark.widthCm)
  return widthcm_;
}
inline void Landmark::set_widthcm(float value) {
  set_has_widthcm();
  widthcm_ = value;
  // @@protoc_insertion_point(field_set:Landmark.widthCm)
}

// optional float heightCm = 7;
inline bool Landmark::has_heightcm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Landmark::set_has_heightcm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Landmark::clear_has_heightcm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Landmark::clear_heightcm() {
  heightcm_ = 0;
  clear_has_heightcm();
}
inline float Landmark::heightcm() const {
  // @@protoc_insertion_point(field_get:Landmark.heightCm)
  return heightcm_;
}
inline void Landmark::set_heightcm(float value) {
  set_has_heightcm();
  heightcm_ = value;
  // @@protoc_insertion_point(field_set:Landmark.heightCm)
}

// optional int32 countryCode = 8;
inline bool Landmark::has_countrycode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Landmark::set_has_countrycode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Landmark::clear_has_countrycode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Landmark::clear_countrycode() {
  countrycode_ = 0;
  clear_has_countrycode();
}
inline ::google::protobuf::int32 Landmark::countrycode() const {
  // @@protoc_insertion_point(field_get:Landmark.countryCode)
  return countrycode_;
}
inline void Landmark::set_countrycode(::google::protobuf::int32 value) {
  set_has_countrycode();
  countrycode_ = value;
  // @@protoc_insertion_point(field_set:Landmark.countryCode)
}

// -------------------------------------------------------------------

// Lane

// optional .Geometry centerLine = 1;
inline bool Lane::has_centerline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lane::set_has_centerline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lane::clear_has_centerline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lane::clear_centerline() {
  if (centerline_ != NULL) centerline_->::Geometry::Clear();
  clear_has_centerline();
}
inline const ::Geometry& Lane::centerline() const {
  // @@protoc_insertion_point(field_get:Lane.centerLine)
  return centerline_ != NULL ? *centerline_ : *default_instance_->centerline_;
}
inline ::Geometry* Lane::mutable_centerline() {
  set_has_centerline();
  if (centerline_ == NULL) centerline_ = new ::Geometry;
  // @@protoc_insertion_point(field_mutable:Lane.centerLine)
  return centerline_;
}
inline ::Geometry* Lane::release_centerline() {
  clear_has_centerline();
  ::Geometry* temp = centerline_;
  centerline_ = NULL;
  return temp;
}
inline void Lane::set_allocated_centerline(::Geometry* centerline) {
  delete centerline_;
  centerline_ = centerline;
  if (centerline) {
    set_has_centerline();
  } else {
    clear_has_centerline();
  }
  // @@protoc_insertion_point(field_set_allocated:Lane.centerLine)
}

// optional .LaneType type = 2;
inline bool Lane::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lane::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lane::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Lane::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::LaneType Lane::type() const {
  // @@protoc_insertion_point(field_get:Lane.type)
  return static_cast< ::LaneType >(type_);
}
inline void Lane::set_type(::LaneType value) {
  assert(::LaneType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Lane.type)
}

// optional uint32 laneId = 3;
inline bool Lane::has_laneid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Lane::set_has_laneid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Lane::clear_has_laneid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Lane::clear_laneid() {
  laneid_ = 0u;
  clear_has_laneid();
}
inline ::google::protobuf::uint32 Lane::laneid() const {
  // @@protoc_insertion_point(field_get:Lane.laneId)
  return laneid_;
}
inline void Lane::set_laneid(::google::protobuf::uint32 value) {
  set_has_laneid();
  laneid_ = value;
  // @@protoc_insertion_point(field_set:Lane.laneId)
}

// repeated uint32 predecessorLaneIds = 4;
inline int Lane::predecessorlaneids_size() const {
  return predecessorlaneids_.size();
}
inline void Lane::clear_predecessorlaneids() {
  predecessorlaneids_.Clear();
}
inline ::google::protobuf::uint32 Lane::predecessorlaneids(int index) const {
  // @@protoc_insertion_point(field_get:Lane.predecessorLaneIds)
  return predecessorlaneids_.Get(index);
}
inline void Lane::set_predecessorlaneids(int index, ::google::protobuf::uint32 value) {
  predecessorlaneids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Lane.predecessorLaneIds)
}
inline void Lane::add_predecessorlaneids(::google::protobuf::uint32 value) {
  predecessorlaneids_.Add(value);
  // @@protoc_insertion_point(field_add:Lane.predecessorLaneIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Lane::predecessorlaneids() const {
  // @@protoc_insertion_point(field_list:Lane.predecessorLaneIds)
  return predecessorlaneids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Lane::mutable_predecessorlaneids() {
  // @@protoc_insertion_point(field_mutable_list:Lane.predecessorLaneIds)
  return &predecessorlaneids_;
}

// optional uint32 predecessorSectionId = 5;
inline bool Lane::has_predecessorsectionid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Lane::set_has_predecessorsectionid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Lane::clear_has_predecessorsectionid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Lane::clear_predecessorsectionid() {
  predecessorsectionid_ = 0u;
  clear_has_predecessorsectionid();
}
inline ::google::protobuf::uint32 Lane::predecessorsectionid() const {
  // @@protoc_insertion_point(field_get:Lane.predecessorSectionId)
  return predecessorsectionid_;
}
inline void Lane::set_predecessorsectionid(::google::protobuf::uint32 value) {
  set_has_predecessorsectionid();
  predecessorsectionid_ = value;
  // @@protoc_insertion_point(field_set:Lane.predecessorSectionId)
}

// -------------------------------------------------------------------

// LaneBoundary

// optional .Geometry geometry = 1;
inline bool LaneBoundary::has_geometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneBoundary::set_has_geometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneBoundary::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneBoundary::clear_geometry() {
  if (geometry_ != NULL) geometry_->::Geometry::Clear();
  clear_has_geometry();
}
inline const ::Geometry& LaneBoundary::geometry() const {
  // @@protoc_insertion_point(field_get:LaneBoundary.geometry)
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::Geometry* LaneBoundary::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::Geometry;
  // @@protoc_insertion_point(field_mutable:LaneBoundary.geometry)
  return geometry_;
}
inline ::Geometry* LaneBoundary::release_geometry() {
  clear_has_geometry();
  ::Geometry* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void LaneBoundary::set_allocated_geometry(::Geometry* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
  // @@protoc_insertion_point(field_set_allocated:LaneBoundary.geometry)
}

// optional .LaneBoundaryType type = 2;
inline bool LaneBoundary::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneBoundary::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneBoundary::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneBoundary::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::LaneBoundaryType LaneBoundary::type() const {
  // @@protoc_insertion_point(field_get:LaneBoundary.type)
  return static_cast< ::LaneBoundaryType >(type_);
}
inline void LaneBoundary::set_type(::LaneBoundaryType value) {
  assert(::LaneBoundaryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:LaneBoundary.type)
}

// -------------------------------------------------------------------

// LaneModel

// repeated .Lane lanes = 1;
inline int LaneModel::lanes_size() const {
  return lanes_.size();
}
inline void LaneModel::clear_lanes() {
  lanes_.Clear();
}
inline const ::Lane& LaneModel::lanes(int index) const {
  // @@protoc_insertion_point(field_get:LaneModel.lanes)
  return lanes_.Get(index);
}
inline ::Lane* LaneModel::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:LaneModel.lanes)
  return lanes_.Mutable(index);
}
inline ::Lane* LaneModel::add_lanes() {
  // @@protoc_insertion_point(field_add:LaneModel.lanes)
  return lanes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lane >&
LaneModel::lanes() const {
  // @@protoc_insertion_point(field_list:LaneModel.lanes)
  return lanes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lane >*
LaneModel::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:LaneModel.lanes)
  return &lanes_;
}

// repeated .LaneBoundary boundaries = 2;
inline int LaneModel::boundaries_size() const {
  return boundaries_.size();
}
inline void LaneModel::clear_boundaries() {
  boundaries_.Clear();
}
inline const ::LaneBoundary& LaneModel::boundaries(int index) const {
  // @@protoc_insertion_point(field_get:LaneModel.boundaries)
  return boundaries_.Get(index);
}
inline ::LaneBoundary* LaneModel::mutable_boundaries(int index) {
  // @@protoc_insertion_point(field_mutable:LaneModel.boundaries)
  return boundaries_.Mutable(index);
}
inline ::LaneBoundary* LaneModel::add_boundaries() {
  // @@protoc_insertion_point(field_add:LaneModel.boundaries)
  return boundaries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LaneBoundary >&
LaneModel::boundaries() const {
  // @@protoc_insertion_point(field_list:LaneModel.boundaries)
  return boundaries_;
}
inline ::google::protobuf::RepeatedPtrField< ::LaneBoundary >*
LaneModel::mutable_boundaries() {
  // @@protoc_insertion_point(field_mutable_list:LaneModel.boundaries)
  return &boundaries_;
}

// -------------------------------------------------------------------

// RoadSection

// optional uint32 sectionId = 1;
inline bool RoadSection::has_sectionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadSection::set_has_sectionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadSection::clear_has_sectionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadSection::clear_sectionid() {
  sectionid_ = 0u;
  clear_has_sectionid();
}
inline ::google::protobuf::uint32 RoadSection::sectionid() const {
  // @@protoc_insertion_point(field_get:RoadSection.sectionId)
  return sectionid_;
}
inline void RoadSection::set_sectionid(::google::protobuf::uint32 value) {
  set_has_sectionid();
  sectionid_ = value;
  // @@protoc_insertion_point(field_set:RoadSection.sectionId)
}

// optional .LaneModel laneModel = 2;
inline bool RoadSection::has_lanemodel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadSection::set_has_lanemodel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadSection::clear_has_lanemodel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoadSection::clear_lanemodel() {
  if (lanemodel_ != NULL) lanemodel_->::LaneModel::Clear();
  clear_has_lanemodel();
}
inline const ::LaneModel& RoadSection::lanemodel() const {
  // @@protoc_insertion_point(field_get:RoadSection.laneModel)
  return lanemodel_ != NULL ? *lanemodel_ : *default_instance_->lanemodel_;
}
inline ::LaneModel* RoadSection::mutable_lanemodel() {
  set_has_lanemodel();
  if (lanemodel_ == NULL) lanemodel_ = new ::LaneModel;
  // @@protoc_insertion_point(field_mutable:RoadSection.laneModel)
  return lanemodel_;
}
inline ::LaneModel* RoadSection::release_lanemodel() {
  clear_has_lanemodel();
  ::LaneModel* temp = lanemodel_;
  lanemodel_ = NULL;
  return temp;
}
inline void RoadSection::set_allocated_lanemodel(::LaneModel* lanemodel) {
  delete lanemodel_;
  lanemodel_ = lanemodel;
  if (lanemodel) {
    set_has_lanemodel();
  } else {
    clear_has_lanemodel();
  }
  // @@protoc_insertion_point(field_set_allocated:RoadSection.laneModel)
}

// repeated .Landmark landmarks = 3;
inline int RoadSection::landmarks_size() const {
  return landmarks_.size();
}
inline void RoadSection::clear_landmarks() {
  landmarks_.Clear();
}
inline const ::Landmark& RoadSection::landmarks(int index) const {
  // @@protoc_insertion_point(field_get:RoadSection.landmarks)
  return landmarks_.Get(index);
}
inline ::Landmark* RoadSection::mutable_landmarks(int index) {
  // @@protoc_insertion_point(field_mutable:RoadSection.landmarks)
  return landmarks_.Mutable(index);
}
inline ::Landmark* RoadSection::add_landmarks() {
  // @@protoc_insertion_point(field_add:RoadSection.landmarks)
  return landmarks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Landmark >&
RoadSection::landmarks() const {
  // @@protoc_insertion_point(field_list:RoadSection.landmarks)
  return landmarks_;
}
inline ::google::protobuf::RepeatedPtrField< ::Landmark >*
RoadSection::mutable_landmarks() {
  // @@protoc_insertion_point(field_mutable_list:RoadSection.landmarks)
  return &landmarks_;
}

// optional .Geometry roadSectionCenterLine = 4;
inline bool RoadSection::has_roadsectioncenterline() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoadSection::set_has_roadsectioncenterline() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoadSection::clear_has_roadsectioncenterline() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoadSection::clear_roadsectioncenterline() {
  if (roadsectioncenterline_ != NULL) roadsectioncenterline_->::Geometry::Clear();
  clear_has_roadsectioncenterline();
}
inline const ::Geometry& RoadSection::roadsectioncenterline() const {
  // @@protoc_insertion_point(field_get:RoadSection.roadSectionCenterLine)
  return roadsectioncenterline_ != NULL ? *roadsectioncenterline_ : *default_instance_->roadsectioncenterline_;
}
inline ::Geometry* RoadSection::mutable_roadsectioncenterline() {
  set_has_roadsectioncenterline();
  if (roadsectioncenterline_ == NULL) roadsectioncenterline_ = new ::Geometry;
  // @@protoc_insertion_point(field_mutable:RoadSection.roadSectionCenterLine)
  return roadsectioncenterline_;
}
inline ::Geometry* RoadSection::release_roadsectioncenterline() {
  clear_has_roadsectioncenterline();
  ::Geometry* temp = roadsectioncenterline_;
  roadsectioncenterline_ = NULL;
  return temp;
}
inline void RoadSection::set_allocated_roadsectioncenterline(::Geometry* roadsectioncenterline) {
  delete roadsectioncenterline_;
  roadsectioncenterline_ = roadsectioncenterline;
  if (roadsectioncenterline) {
    set_has_roadsectioncenterline();
  } else {
    clear_has_roadsectioncenterline();
  }
  // @@protoc_insertion_point(field_set_allocated:RoadSection.roadSectionCenterLine)
}

// -------------------------------------------------------------------

// RoadSections

// repeated .RoadSection roadSections = 1;
inline int RoadSections::roadsections_size() const {
  return roadsections_.size();
}
inline void RoadSections::clear_roadsections() {
  roadsections_.Clear();
}
inline const ::RoadSection& RoadSections::roadsections(int index) const {
  // @@protoc_insertion_point(field_get:RoadSections.roadSections)
  return roadsections_.Get(index);
}
inline ::RoadSection* RoadSections::mutable_roadsections(int index) {
  // @@protoc_insertion_point(field_mutable:RoadSections.roadSections)
  return roadsections_.Mutable(index);
}
inline ::RoadSection* RoadSections::add_roadsections() {
  // @@protoc_insertion_point(field_add:RoadSections.roadSections)
  return roadsections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RoadSection >&
RoadSections::roadsections() const {
  // @@protoc_insertion_point(field_list:RoadSections.roadSections)
  return roadsections_;
}
inline ::google::protobuf::RepeatedPtrField< ::RoadSection >*
RoadSections::mutable_roadsections() {
  // @@protoc_insertion_point(field_mutable_list:RoadSections.roadSections)
  return &roadsections_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ShapeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ShapeType>() {
  return ::ShapeType_descriptor();
}
template <> struct is_proto_enum< ::LandmarkType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LandmarkType>() {
  return ::LandmarkType_descriptor();
}
template <> struct is_proto_enum< ::LaneType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LaneType>() {
  return ::LaneType_descriptor();
}
template <> struct is_proto_enum< ::LaneBoundaryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LaneBoundaryType>() {
  return ::LaneBoundaryType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RoadSection_2eproto__INCLUDED
